**real power of modern Java (8 â†’ 17)**: **asynchronous and reactive programming** with `CompletableFuture`, parallel streams, and functional-style concurrency.

By the end of **Week 3**, youâ€™ll be able to build **non-blocking, async microservice-style workflows** â€” something thatâ€™s used in _real-world banking, e-commerce, and distributed systems_.

---

## ğŸ—“ï¸ **WEEK 3: CompletableFuture & Asynchronous Programming (Java 8 â†’ 17)**

### ğŸ¯ **Goal:**

Master Javaâ€™s high-level asynchronous API using `CompletableFuture`, understand async chaining, exception handling, and real-world use cases.

---

## ğŸ§© **Day 1 â€” From Future to CompletableFuture**

### ğŸ§  Concepts:

- `Future` is blocking â†’ `CompletableFuture` is non-blocking.
- Execute async tasks without manually managing threads.

### ğŸ“˜ Example:

```java
import java.util.concurrent.*;

public class BasicCompletableFuture {
    public static void main(String[] args) throws Exception {
        CompletableFuture<Void> cf = CompletableFuture.runAsync(() -> {
            System.out.println(Thread.currentThread().getName() + " running async task");
        });

        cf.get(); // Waits for completion
        System.out.println("Main thread finished");
    }
}
```

### âœ… Key Points:

- `runAsync()` = no return value.
- `supplyAsync()` = returns a result.
- Uses ForkJoinPool by default.

### ğŸ’ª Exercise:

Use `supplyAsync()` to fetch mock data (e.g., "Fetching user profile...") and print the result when ready.

---

## ğŸ§© **Day 2 â€” Chaining Async Tasks (`thenApply`, `thenAccept`)**

### ğŸ§  Concepts:

- You can transform or consume results _asynchronously_ using chains.
- Each `thenApply` creates a new `CompletableFuture`.

### ğŸ“˜ Example:

```java
import java.util.concurrent.*;

public class ChainingExample {
    public static void main(String[] args) throws Exception {
        CompletableFuture.supplyAsync(() -> {
            System.out.println("Fetching user...");
            return "Shrikar";
        })
        .thenApply(name -> "Hello, " + name)
        .thenAccept(greeting -> System.out.println(Thread.currentThread().getName() + " says: " + greeting))
        .get();
    }
}
```

### âœ… Key Points:

- `thenApply()` transforms results.
- `thenAccept()` consumes results (returns void).
- Each stage runs asynchronously.

### ğŸ’ª Exercise:

Chain three async tasks:
â†’ fetch user â†’ calculate loyalty points â†’ print reward eligibility.

---

## ğŸ§© **Day 3 â€” Combining Multiple Async Tasks**

### ğŸ§  Concepts:

- `thenCombine()` combines results of _two futures_.
- `allOf()` waits for _many futures_ to complete.
- `anyOf()` returns when _one completes_.

### ğŸ“˜ Example:

```java
import java.util.concurrent.*;

public class CombineExample {
    public static void main(String[] args) throws Exception {
        CompletableFuture<String> fetchName = CompletableFuture.supplyAsync(() -> "Shrikar");
        CompletableFuture<Integer> fetchAge = CompletableFuture.supplyAsync(() -> 30);

        CompletableFuture<String> combined = fetchName.thenCombine(fetchAge,
                (name, age) -> name + " is " + age + " years old");

        System.out.println(combined.get());
    }
}
```

### ğŸ’ª Example: Wait for all

```java
CompletableFuture<Void> all = CompletableFuture.allOf(
    CompletableFuture.runAsync(() -> System.out.println("Service A")),
    CompletableFuture.runAsync(() -> System.out.println("Service B")),
    CompletableFuture.runAsync(() -> System.out.println("Service C"))
);
all.join();
```

### âœ… Key Points:

- `thenCombine()` merges results.
- `allOf()` â†’ wait for all.
- `anyOf()` â†’ first one done wins.

### ğŸ’ª Exercise:

Run 3 async â€œmicroservicesâ€ (user, balance, transaction) in parallel using `allOf()`.

---

## ğŸ§© **Day 4 â€” Exception Handling in Async Flows**

### ğŸ§  Concepts:

- Handle errors gracefully in async chains.
- Methods:

  - `exceptionally()`
  - `handle()`
  - `whenComplete()`

### ğŸ“˜ Example:

```java
import java.util.concurrent.*;

public class ExceptionHandlingExample {
    public static void main(String[] args) {
        CompletableFuture.supplyAsync(() -> {
            System.out.println("Fetching data...");
            if (true) throw new RuntimeException("Data fetch failed!");
            return "Data";
        })
        .exceptionally(ex -> {
            System.out.println("Error: " + ex.getMessage());
            return "Default Data";
        })
        .thenAccept(System.out::println)
        .join();
    }
}
```

### ğŸ’ª Exercise:

Simulate a network call that fails randomly â€” handle the error using `handle()` and provide a fallback response.

---

## ğŸ§© **Day 5 â€” Custom Executors & Timeouts**

### ğŸ§  Concepts:

- By default, `CompletableFuture` uses **ForkJoinPool.commonPool()**.
- You can pass your own `Executor`.
- Also handle timeouts with:

  - `orTimeout()`
  - `completeOnTimeout()`

### ğŸ“˜ Example:

```java
import java.util.concurrent.*;

public class TimeoutExample {
    public static void main(String[] args) {
        ExecutorService pool = Executors.newFixedThreadPool(2);

        CompletableFuture<String> cf = CompletableFuture
                .supplyAsync(() -> {
                    try { Thread.sleep(2000); } catch (Exception ignored) {}
                    return "Result from async task";
                }, pool)
                .orTimeout(1, TimeUnit.SECONDS)
                .exceptionally(ex -> "Timed out!");

        System.out.println(cf.join());
        pool.shutdown();
    }
}
```

### ğŸ’ª Exercise:

Build a `CompletableFuture` chain that retries a task up to 3 times on timeout.

---

## ğŸ§© **Day 6 â€” Parallel Streams vs CompletableFuture**

### ğŸ§  Concepts:

- Both use the ForkJoin framework.
- `parallelStream()` is simpler but less flexible.
- `CompletableFuture` allows fine-grained control.

### ğŸ“˜ Example:

```java
import java.util.List;

public class ParallelStreamExample {
    public static void main(String[] args) {
        List<String> users = List.of("A", "B", "C", "D", "E");

        users.parallelStream()
             .map(u -> {
                 System.out.println(Thread.currentThread().getName() + " processing " + u);
                 return u.toLowerCase();
             })
             .forEach(System.out::println);
    }
}
```

### âœ… When to Use:

| Use Case                               | Recommended         |
| -------------------------------------- | ------------------- |
| Simple data transformations            | `parallelStream()`  |
| API calls, async workflows             | `CompletableFuture` |
| Error handling, chaining, custom pools | `CompletableFuture` |

### ğŸ’ª Exercise:

Implement a parallel transformation pipeline using both approaches and compare execution times.

---

## ğŸ§© **Day 7 â€” Mini Project: Async Microservice Aggregator**

### ğŸ¯ Problem:

Simulate a dashboard fetching data from 3 microservices in parallel:

- **AccountService**
- **LoanService**
- **CreditScoreService**

### ğŸ“˜ Example:

```java
import java.util.concurrent.*;

public class AsyncMicroserviceAggregator {
    static CompletableFuture<String> getAccountService() {
        return CompletableFuture.supplyAsync(() -> {
            sleep(1000);
            return "Account: â‚¹10,000";
        });
    }

    static CompletableFuture<String> getLoanService() {
        return CompletableFuture.supplyAsync(() -> {
            sleep(1500);
            return "Loan: â‚¹2,00,000";
        });
    }

    static CompletableFuture<String> getCreditScoreService() {
        return CompletableFuture.supplyAsync(() -> {
            sleep(800);
            return "Credit Score: 790";
        });
    }

    static void sleep(long ms) {
        try { Thread.sleep(ms); } catch (Exception ignored) {}
    }

    public static void main(String[] args) {
        CompletableFuture<Void> all = CompletableFuture.allOf(
                getAccountService(), getLoanService(), getCreditScoreService()
        );

        all.thenRun(() -> {
            try {
                System.out.println("\n=== Dashboard Data ===");
                System.out.println(getAccountService().get());
                System.out.println(getLoanService().get());
                System.out.println(getCreditScoreService().get());
            } catch (Exception e) {
                e.printStackTrace();
            }
        }).join();

        System.out.println("Dashboard loaded asynchronously!");
    }
}
```

### âœ… Demonstrates:

- Parallel async calls
- Non-blocking aggregation
- Real-world pattern for microservices / REST APIs

---

## ğŸ **End of Week 3 Recap**

You mastered:
âœ… `CompletableFuture` basics
âœ… Chaining & combining async tasks
âœ… Exception handling & timeouts
âœ… Custom executors
âœ… Parallel streams vs CompletableFuture
âœ… Async microservice orchestration

---

### ğŸªœ **Next: Week 4 â€” Advanced Concurrency (Flow API, Virtual Threads & Reactive Streams)**

In Week 4, weâ€™ll go deep into:

- Java 9+ **Flow API** (Reactive Streams)
- **Virtual Threads** (Java 17/19 Project Loom)
- Structured concurrency
- Designing async pipelines for performance and resilience
- Final mini project: _Reactive event-driven banking system_

---
