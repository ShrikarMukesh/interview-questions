---

 **why `Comparator` is still a _functional interface_** even though it _appears_ to have multiple abstract methods.

---

## ğŸ§© First: What is a Functional Interface?

A **functional interface** is an interface that has **exactly one abstract method**.
It can have:

- Any number of **default methods** (with implementations),
- Any number of **static methods**, and
- Methods inherited from `Object` (like `equals`, `hashCode`, `toString`).

ğŸ‘‰ Only **one abstract method** counts toward the _functional interface contract_.

---

## ğŸ§  Now, Look at `Comparator` Source (Java 8+)

Hereâ€™s the key part of the `java.util.Comparator` interface (simplified):

```java
@FunctionalInterface
public interface Comparator<T> {
    int compare(T o1, T o2);

    // Many other methods â€” but most are default or static
    boolean equals(Object obj); // from Object

    default Comparator<T> reversed() { ... }

    default Comparator<T> thenComparing(Comparator<? super T> other) { ... }

    static <T, U extends Comparable<? super U>> Comparator<T> comparing(
            Function<? super T, ? extends U> keyExtractor) { ... }
}
```

---

## ğŸ” Letâ€™s analyze the methods

| Method                       | Type          | Abstract?  | Explanation                                      |
| ---------------------------- | ------------- | ---------- | ------------------------------------------------ |
| `int compare(T o1, T o2)`    | Instance      | âœ… Yes     | The **only abstract method** you must implement. |
| `boolean equals(Object obj)` | From `Object` | ğŸš« Ignored | Not counted for functional interface rule.       |
| `reversed()`                 | Default       | ğŸš« No      | Has a body â†’ not abstract.                       |
| `thenComparing()`            | Default       | ğŸš« No      | Has a body â†’ not abstract.                       |
| `comparing()`                | Static        | ğŸš« No      | Static â†’ not abstract.                           |

---

## âœ… So Java says: â€œComparator has **one** abstract method â€” `compare()`â€

Thatâ€™s why this is valid:

```java
Comparator<Integer> c = (a, b) -> a - b;
```

Under the hood, Java sees:

- `Comparator` has one abstract method â†’ `compare(T o1, T o2)`
- Therefore, your lambda `(a, b) -> a - b` implements that method.

---

## ğŸ§© What about `equals(Object obj)`?

Every interface **implicitly declares** the methods of `Object`, but **they donâ€™t count** toward the abstract method count for functional interfaces.

From the Java Language Specification (Â§9.8):

> â€œA functional interface type is an interface that has just one abstract method, aside from the methods of `Object` that it overrides.â€

So `equals(Object)` is ignored.

---

## âš™ï¸ Proof â€” You can check annotation in source code

If you open the actual JDK source:

```java
@FunctionalInterface
public interface Comparator<T> {
    int compare(T o1, T o2);
    ...
}
```

Itâ€™s **explicitly annotated** as a functional interface.

If it really had more than one abstract method, the compiler would throw an error:

```
Unexpected @FunctionalInterface annotation
multiple non-overriding abstract methods found
```

â€¦but it doesnâ€™t â€” because only one abstract method (`compare`) exists.

---

## ğŸ§© Summary Table

| Type of method          | Counts toward functional interface rule? | Example in `Comparator`         |
| ----------------------- | ---------------------------------------- | ------------------------------- |
| Abstract                | âœ… Yes                                   | `compare()`                     |
| Default                 | ğŸš« No                                    | `thenComparing()`, `reversed()` |
| Static                  | ğŸš« No                                    | `comparing()`                   |
| Inherited from `Object` | ğŸš« No                                    | `equals()`                      |

---

## ğŸ”¥ Quick Example

```java
Comparator<String> comp = (s1, s2) -> s1.compareToIgnoreCase(s2);

System.out.println(comp.compare("apple", "Banana")); // returns negative
```

âœ… Works fine because the lambda matches `int compare(T o1, T o2)`.

---

## âœ… Summary in one line

> `Comparator` is a **functional interface** because it has only **one abstract method (`compare`)**;
> all others are **default, static, or inherited from `Object`**, so they donâ€™t count.

---

---
